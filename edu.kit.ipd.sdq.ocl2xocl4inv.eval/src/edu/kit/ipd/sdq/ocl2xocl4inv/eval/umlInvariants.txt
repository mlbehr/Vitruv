class Activity 
invariant maximum_one_parameter_node 
ownedParameter->forAll(p | p.direction <> ParameterDirectionKind::inout implies node->select( oclIsKindOf(ActivityParameterNode) and oclAsType(ActivityParameterNode).parameter = p)->size()= 1)
invariant maximum_two_parameter_nodes 
ownedParameter->forAll(p | p.direction = ParameterDirectionKind::inout implies let associatedNodes : Set(ActivityNode) = node->select( oclIsKindOf(ActivityParameterNode) and oclAsType(ActivityParameterNode).parameter = p) in associatedNodes->size()=2 and associatedNodes->select(incoming->notEmpty())->size()<=1 and associatedNodes->select(outgoing->notEmpty())->size()<=1 )
class Behavior 
invariant parameters_match 
specification <> null implies ownedParameter->size() = specification.ownedParameter->size()
invariant passive_class
not isActive implies (ownedReception->isEmpty() and classifierBehavior = null)
class BehavioredClassifier
invariant class_behavior
classifierBehavior->notEmpty() implies classifierBehavior.specification->isEmpty()
class Classifier 
invariant specialize_type
parents()->forAll(c | self.maySpecializeType(c))
invariant maps_to_generalization_set
powertypeExtent->forAll( gs | gs.generalization->forAll( gen | not (gen.general = self) and not gen.general.allParents()->includes(self) and not (gen.specific = self) and not self.allParents()->includes(gen.specific) ))
invariant non_final_parents
parents()->forAll(not isFinalSpecialization)
invariant no_cycles_in_generalization
not allParents()->includes(self)
class Namespace 
invariant members_distinguishable
membersAreDistinguishable()
invariant cannot_import_self
packageImport.importedPackage.oclAsType(Namespace)->excludes(self)
invariant cannot_import_ownedMembers
elementImport.importedElement.oclAsType(Element)->excludesAll(ownedMember)
class NamedElement 
invariant visibility_needs_ownership
(namespace = null and owner <> null) implies visibility = null
invariant has_qualified_name
(name <> null and allNamespaces()->select(ns | ns.name = null)->isEmpty()) implies qualifiedName = allNamespaces()->iterate( ns : Namespace; agg: String = name | ns.name.concat(self.separator()).concat(agg))
invariant has_no_qualified_name 
name=null or allNamespaces()->select( ns | ns.name=null )->notEmpty() implies qualifiedName = null
class Element 
invariant has_owner 
mustBeOwned() implies owner->notEmpty()
invariant not_own_self 
not allOwnedElements()->includes(self)
class Stereotype 
invariant binaryAssociationsOnly 
ownedAttribute.association->forAll(memberEnd->size()=2)
invariant generalize 
allParents()->forAll(oclIsKindOf(Stereotype)) and Classifier.allInstances()->forAll(c | c.allParents()->exists(oclIsKindOf(Stereotype)) implies c.oclIsKindOf(Stereotype))
invariant associationEndOwnership 
ownedAttribute ->select(association->notEmpty() and not association.oclIsKindOf(Extension) and not type.oclIsKindOf(Stereotype)) ->forAll(opposite.owner = association)
invariant base_property_multiplicity_multiple_extension 
class Profile 
invariant metaclass_reference_not_specialized
metaclassReference.importedElement-> select(c | c.oclIsKindOf(Classifier) and (c.oclAsType(Classifier).allParents()->collect(namespace)->includes(self)))->isEmpty() and packagedElement-> select(oclIsKindOf(Classifier))->collect(oclAsType(Classifier).allParents())-> intersection(metaclassReference.importedElement->select(oclIsKindOf(Classifier))->collect(oclAsType(Classifier)))->isEmpty()
invariant references_same_metamodel
metamodelReference.importedPackage.elementImport.importedElement.allOwningPackages()-> union(metaclassReference.importedElement.allOwningPackages() )->notEmpty()
class Package 
invariant elements_public_or_private 
packagedElement->forAll(e | e.visibility<> null implies e.visibility = VisibilityKind::public or e.visibility = VisibilityKind::private)
class PackageableElement 
invariant namespace_needs_visibility 
visibility = null implies namespace = null
class TemplateParameter 
invariant must_be_compatible 
default <> null implies default.isCompatibleWith(parameteredElement)
class TemplateSignature 
invariant own_elements
template.ownedElement->includesAll(parameter.parameteredElement->asSet() - parameter.ownedParameteredElement->asSet())
invariant unique_parameters
parameter->forAll( p1, p2 | (p1 <> p2 and p1.parameteredElement.oclIsKindOf(NamedElement) and p2.parameteredElement.oclIsKindOf(NamedElement) ) implies p1.parameteredElement.oclAsType(NamedElement).name <> p2.parameteredElement.oclAsType(NamedElement).name)
class TemplateBinding 
invariant parameter_substitution_formal 
parameterSubstitution->forAll(b | signature.parameter->includes(b.formal))
invariant one_parameter_substitution
signature.parameter->forAll(p | parameterSubstitution->select(b | b.formal = p)->size() <= 1)
class TemplateParameterSubstitution 
invariant must_be_compatible 
actual->forAll(a | a.isCompatibleWith(formal.parameteredElement))
class Association 
invariant specialized_end_number 
parents()->select(oclIsKindOf(Association)).oclAsType(Association)->forAll(p | p.memberEnd->size() = self.memberEnd->size())
invariant specialized_end_types
Sequence{memberEnd->size()}-> forAll(i | general->select(oclIsKindOf(Association)).oclAsType(Association)-> forAll(ga | self.memberEnd->at(i).type.conformsTo(ga.memberEnd->at(i).type)))
invariant binary_associations 
memberEnd->exists(aggregation <> AggregationKind::none) implies (memberEnd->size() = 2 and memberEnd->exists(aggregation = AggregationKind::none))
invariant association_ends 
memberEnd->size() > 2 implies ownedEnd->includesAll(memberEnd)
invariant ends_must_be_typed 
memberEnd->forAll(type->notEmpty())
class Property 
invariant subsetting_context_conforms
subsettedProperty->notEmpty() implies (subsettingContext()->notEmpty() and subsettingContext()->forAll (sc | subsettedProperty->forAll(sp | sp.subsettingContext()->exists(c | sc.conformsTo(c)))))
invariant derived_union_is_read_only 
isDerivedUnion implies isReadOnly
invariant multiplicity_of_composite 
isComposite and association <> null implies opposite.upperBound() <= 1
invariant redefined_property_inherited
(redefinedProperty->notEmpty()) implies (redefinitionContext->notEmpty() and redefinedProperty->forAll(rp| ((redefinitionContext->collect(fc| fc.allParents()))->asSet())->collect(c| c.allFeatures())->asSet()->includes(rp)))
invariant subsetting_rules 
subsettedProperty->forAll(sp | self.type.conformsTo(sp.type) and ((self.upperBound()->notEmpty() and sp.upperBound()->notEmpty()) implies self.upperBound() <= sp.upperBound() ))
invariant binding_to_attribute
(self.isAttribute() and (templateParameterSubstitution->notEmpty()) implies (templateParameterSubstitution->forAll(ts | ts.formal.oclIsKindOf(Property) and ts.formal.oclAsType(Property).isAttribute())))
invariant derived_union_is_derived 
isDerivedUnion implies isDerived
invariant deployment_target
deployment->notEmpty() implies owner.oclIsKindOf(Node) and Node.allInstances()->exists(n | n.part->exists(p | p = self))
invariant subsetted_property_names 
subsettedProperty->forAll(sp | sp.name <> name)
invariant type_of_opposite_end 
(opposite->notEmpty() and owningAssociation->isEmpty()) implies classifier = opposite.type
invariant qualified_is_association_end 
qualifier->notEmpty() implies association->notEmpty()
class ConnectorEnd 
invariant role_and_part_with_port
partWithPort->notEmpty() implies (role.oclIsKindOf(Port) and partWithPort.type.oclAsType(Namespace).member->includes(role))
invariant part_with_port_empty 
(role.oclIsKindOf(Port) and role.owner = connector.owner) implies partWithPort->isEmpty()
invariant multiplicity 
self.compatibleWith(definingEnd)
invariant self_part_with_port 
partWithPort->notEmpty() implies not partWithPort.oclIsKindOf(Port)
class MultiplicityElement
invariant upper_ge_lower 
upperBound() >= lowerBound()
invariant lower_ge_0 
lowerBound() >= 0
invariant value_specification_no_side_effects 
invariant value_specification_constant 
invariant lower_is_integer 
lowerValue <> null implies lowerValue.integerValue() <> null
invariant upper_is_unlimitedNatural 
upperValue <> null implies upperValue.unlimitedValue() <> null
class DeploymentSpecification 
invariant deployment_target 
deployment->forAll (location.oclIsKindOf(ExecutionEnvironment))
invariant deployed_elements 
deployment->forAll (location.deployedElement->forAll (oclIsKindOf(Component)))
class OpaqueExpression 
invariant language_body_size
language->notEmpty() implies (_'body'->size() = language->size())
invariant one_return_result_parameter
behavior <> null implies behavior.ownedParameter->select(direction=ParameterDirectionKind::return)->size() = 1
invariant only_return_result_parameters 
behavior <> null implies behavior.ownedParameter->select(direction<>ParameterDirectionKind::return)->isEmpty()
class Parameter 
invariant in_and_out 
(effect = ParameterEffectKind::delete implies (direction = ParameterDirectionKind::_'in' or direction = ParameterDirectionKind::inout)) and (effect = ParameterEffectKind::create implies (direction = ParameterDirectionKind::out or direction = ParameterDirectionKind::inout or direction = ParameterDirectionKind::return))
invariant not_exception 
isException implies (direction <> ParameterDirectionKind::_'in' and direction <> ParameterDirectionKind::inout)
invariant connector_end 
end->notEmpty() implies collaboration->notEmpty()
invariant reentrant_behaviors 
(isStream and behavior <> null) implies not behavior.isReentrant
invariant stream_and_exception 
not (isException and isStream)
invariant object_effect 
(type.oclIsKindOf(DataType)) implies (effect = null)
class Operation 
invariant at_most_one_return
self.ownedParameter->select(direction = ParameterDirectionKind::return)->size() <= 1
invariant only_body_for_query 
bodyCondition <> null implies isQuery
class BehavioralFeature 
invariant abstract_no_method 
isAbstract implies method->isEmpty()
class RedefinableElement 
invariant redefinition_consistent 
redefinedElement->forAll(re | re.isConsistentWith(self))
invariant non_leaf_redefinition 
redefinedElement->forAll(re | not re.isLeaf)
invariant redefinition_context_valid 
redefinedElement->forAll(re | self.isRedefinitionContextValid(re))
class ParameterSet 
invariant same_parameterized_entity 
parameter->forAll(p1, p2 | self.owner = p1.owner and self.owner = p2.owner and p1.direction = p2.direction)
invariant input
((parameter->exists(direction = ParameterDirectionKind::_'in')) implies behavioralFeature.ownedParameter->select(p | p.direction = ParameterDirectionKind::_'in' and p.parameterSet->isEmpty())->forAll(isStream)) and ((parameter->exists(direction = ParameterDirectionKind::out)) implies behavioralFeature.ownedParameter->select(p | p.direction = ParameterDirectionKind::out and p.parameterSet->isEmpty())->forAll(isStream))
invariant two_parameter_sets
parameter->forAll(parameterSet->forAll(s1, s2 | s1->size() = s2->size() implies s1.parameter->exists(p | not s2.parameter->includes(p))))
class Constraint 
invariant boolean_value 
invariant no_side_effects 
invariant not_apply_to_self 
not constrainedElement->includes(self)
class Interface 
invariant visibility 
feature->forAll(visibility = VisibilityKind::public)
class Reception 
invariant same_name_as_signal 
name = signal.name
invariant same_structure_as_signal 
signal.ownedAttribute->size() = ownedParameter->size() and Sequence{signal.ownedAttribute->size()}->forAll( i | ownedParameter->at(i).direction = ParameterDirectionKind::_'in' and ownedParameter->at(i).name = signal.ownedAttribute->at(i).name and ownedParameter->at(i).type = signal.ownedAttribute->at(i).type and ownedParameter->at(i).lowerBound() = signal.ownedAttribute->at(i).lowerBound() and ownedParameter->at(i).upperBound() = signal.ownedAttribute->at(i).upperBound() )
class ProtocolStateMachine 
invariant classifier_context 
_'' <> null and specification = null
invariant deep_or_shallow_history
region->forAll (r | r.subvertex->forAll (v | v.oclIsKindOf(Pseudostate) implies ((v.oclAsType(Pseudostate).kind <> PseudostateKind::deepHistory) and (v.oclAsType(Pseudostate).kind <> PseudostateKind::shallowHistory))))
invariant entry_exit_do
region->forAll(r | r.subvertex->forAll(v | v.oclIsKindOf(State) implies (v.oclAsType(State).entry->isEmpty() and v.oclAsType(State).exit->isEmpty() and v.oclAsType(State).doActivity->isEmpty())))
invariant protocol_transitions 
region->forAll(r | r.transition->forAll(t | t.oclIsTypeOf(ProtocolTransition)))
class StateMachine 
invariant connection_points 
connectionPoint->forAll (kind = PseudostateKind::entryPoint or kind = PseudostateKind::exitPoint)
invariant classifier_context 
_'' <> null implies not _''.oclIsKindOf(Interface)
invariant method 
specification <> null implies connectionPoint->isEmpty()
invariant context_classifier 
specification <> null implies ( _'' <> null and specification.featuringClassifier->exists(c | c = _''))
class Pseudostate 
invariant transitions_outgoing
(kind = PseudostateKind::fork) implies outgoing->forAll(t1:Transition, t2:Transition | let contState:State = containingStateMachine().LCAState(t1.target, t2.target) in ((contState <> null) and (contState.region ->exists(r1:Region, r2: Region | (r1 <> r2) and t1.target.isContainedInRegion(r1) and t2.target.isContainedInRegion(r2)))))
invariant choice_vertex
(kind = PseudostateKind::choice) implies (incoming->size() >= 1 and outgoing->size() >= 1)
invariant outgoing_from_initial 
(kind = PseudostateKind::initial) implies (outgoing.guard = null and outgoing.trigger->isEmpty())
invariant join_vertex
(kind = PseudostateKind::join) implies (outgoing->size() = 1 and incoming->size() >= 2)
invariant junction_vertex
(kind = PseudostateKind::junction) implies (incoming->size() >= 1 and outgoing->size() >= 1)
invariant history_vertices
((kind = PseudostateKind::deepHistory) or (kind = PseudostateKind::shallowHistory)) implies (outgoing->size() <= 1)
invariant initial_vertex
(kind = PseudostateKind::initial) implies (outgoing->size() <= 1)
invariant fork_vertex
(kind = PseudostateKind::fork) implies (incoming->size() = 1 and outgoing->size() >= 2)
invariant transitions_incoming
(kind = PseudostateKind::join) implies incoming->forAll(t1:Transition, t2:Transition | let contState:State = containingStateMachine().LCAState(t1.source, t2.source) in ((contState <> null) and (contState.region ->exists(r1:Region, r2: Region | (r1 <> r2) and t1.source.isContainedInRegion(r1) and t2.source.isContainedInRegion(r2)))))
class Region 
invariant deep_history_vertex
self.subvertex->select (oclIsKindOf(Pseudostate))->collect(oclAsType(Pseudostate))-> select(kind = PseudostateKind::deepHistory)->size() <= 1
invariant shallow_history_vertex
subvertex->select(oclIsKindOf(Pseudostate))->collect(oclAsType(Pseudostate))-> select(kind = PseudostateKind::shallowHistory)->size() <= 1
invariant owned 
(stateMachine <> null implies state = null) and (state <> null implies stateMachine = null)
invariant initial_vertex
self.subvertex->select (oclIsKindOf(Pseudostate))->collect(oclAsType(Pseudostate))-> select(kind = PseudostateKind::initial)->size() <= 1
class State
invariant entry_or_exit 
connectionPoint->forAll(kind = PseudostateKind::entryPoint or kind = PseudostateKind::exitPoint)
invariant submachine_states 
isSubmachineState implies connection->notEmpty( )
invariant composite_states 
connectionPoint->notEmpty() implies isComposite
invariant destinations_or_sources_of_transitions 
self.isSubmachineState implies (self.connection->forAll (cp | cp.entry->forAll (ps | ps.stateMachine = self.submachine) and cp.exit->forAll (ps | ps.stateMachine = self.submachine)))
invariant submachine_or_regions 
isComposite implies not isSubmachineState
class ConnectionPointReference 
invariant exit_pseudostates 
exit->forAll(kind = PseudostateKind::exitPoint)
invariant entry_pseudostates 
entry->forAll(kind = PseudostateKind::entryPoint)
class Trigger 
invariant trigger_with_ports 
port->notEmpty() implies event.oclIsKindOf(MessageEvent)
class Port 
invariant port_aggregation 
aggregation = AggregationKind::composite
invariant default_value 
type.oclIsKindOf(Interface) implies defaultValue->isEmpty()
invariant encapsulated_owner 
owner = encapsulatedClassifier
class Transition 
invariant state_is_external 
(kind = TransitionKind::external) implies not (source.oclIsKindOf(Pseudostate) and source.oclAsType(Pseudostate).kind = PseudostateKind::entryPoint)
invariant join_segment_guards 
(target.oclIsKindOf(Pseudostate) and target.oclAsType(Pseudostate).kind = PseudostateKind::join) implies (guard = null and trigger->isEmpty())
invariant state_is_internal 
(kind = TransitionKind::internal) implies (source.oclIsKindOf (State) and source = target)
invariant outgoing_pseudostates 
source.oclIsKindOf(Pseudostate) and (source.oclAsType(Pseudostate).kind <> PseudostateKind::initial) implies trigger->isEmpty()
invariant join_segment_state 
(target.oclIsKindOf(Pseudostate) and target.oclAsType(Pseudostate).kind = PseudostateKind::join) implies (source.oclIsKindOf(State))
invariant fork_segment_state 
(source.oclIsKindOf(Pseudostate) and source.oclAsType(Pseudostate).kind = PseudostateKind::fork) implies (target.oclIsKindOf(State))
invariant state_is_local 
(kind = TransitionKind::local) implies ((source.oclIsKindOf (State) and source.oclAsType(State).isComposite) or (source.oclIsKindOf (Pseudostate) and source.oclAsType(Pseudostate).kind = PseudostateKind::entryPoint))
invariant initial_transition 
(source.oclIsKindOf(Pseudostate) and container.stateMachine->notEmpty()) implies trigger->isEmpty()
invariant fork_segment_guards 
(source.oclIsKindOf(Pseudostate) and source.oclAsType(Pseudostate).kind = PseudostateKind::fork) implies (guard = null and trigger->isEmpty())
class OperationTemplateParameter 
invariant match_default_signature
defaultOp.ownedParameter->size() = parameteredElement.ownedParameter->size() and Sequence{ defaultOp.ownedParameter->size()}->forAll( ix | let p1: Parameter = defaultOp.ownedParameter->at(ix), p2 : Parameter = parameteredElement.ownedParameter->at(ix) in p1.type = p2.type and p1.upper = p2.upper and p1.lower = p2.lower and p1.direction = p2.direction and p1.isOrdered = p2.isOrdered and p1.isUnique = p2.isUnique)))
class Enumeration 
invariant immutable 
ownedAttribute->forAll(isReadOnly)
class InstanceSpecification 
invariant deployment_artifact 
deploymentForArtifact->notEmpty() implies classifier->exists(oclIsKindOf(Artifact))
invariant structural_feature
classifier->forAll(c | (c.allSlottableFeatures()->forAll(f | slot->select(s | s.definingFeature = f)->size() <= 1)))
invariant defining_feature
slot->forAll(s | classifier->exists (c | c.allSlottableFeatures()->includes (s.definingFeature)))
invariant deployment_target
deployment->notEmpty() implies classifier->exists(node | node.oclIsKindOf(Node) and Node.allInstances()->exists(n | n.part->exists(p | p.type = node)))
class ElementImport 
invariant imported_element_is_public 
importedElement.visibility <> null implies importedElement.visibility = VisibilityKind::public
invariant visibility_public_or_private 
visibility = VisibilityKind::public or visibility = VisibilityKind::private
class PackageImport 
invariant public_or_private 
visibility = VisibilityKind::public or visibility = VisibilityKind::private
class Extension
invariant non_owned_end 
metaclassEnd()->notEmpty() and metaclassEnd().type.oclIsKindOf(Class)
invariant is_binary
memberEnd->size() = 2
class ExtensionEnd 
invariant multiplicity 
(lowerBound() = 0 or lowerBound() = 1) and upperBound() = 1
invariant aggregation 
self.aggregation = AggregationKind::composite
class StringExpression 
invariant operands 
operand->forAll (oclIsKindOf (LiteralString))
invariant subexpressions 
if subExpression->notEmpty() then operand->isEmpty() else operand->notEmpty() endif
class CollaborationUse 
invariant client_elements
roleBinding->collect(client)->forAll(ne1, ne2 | ne1.oclIsKindOf(ConnectableElement) and ne2.oclIsKindOf(ConnectableElement) and let ce1 : ConnectableElement = ne1.oclAsType(ConnectableElement), ce2 : ConnectableElement = ne2.oclAsType(ConnectableElement) in ce1.structuredClassifier = ce2.structuredClassifier) and roleBinding->collect(supplier)->forAll(ne1, ne2 | ne1.oclIsKindOf(ConnectableElement) and ne2.oclIsKindOf(ConnectableElement) and let ce1 : ConnectableElement = ne1.oclAsType(ConnectableElement), ce2 : ConnectableElement = ne2.oclAsType(ConnectableElement) in ce1.collaboration = ce2.collaboration)
invariant every_role
type.collaborationRole->forAll(role | roleBinding->exists(rb | rb.supplier->includes(role)))
invariant connectors
type.ownedConnector->forAll(connector | let rolesConnectedInCollab : Set(ConnectableElement) = connector.end.role->asSet(), relevantBindings : Set(Dependency) = roleBinding->select(rb | rb.supplier->intersection(rolesConnectedInCollab)->notEmpty()), boundRoles : Set(ConnectableElement) = relevantBindings->collect(client.oclAsType(ConnectableElement))->asSet(), contextClassifier : StructuredClassifier = boundRoles->any(true).structuredClassifier->any(true) in contextClassifier.ownedConnector->exists( correspondingConnector | correspondingConnector.end.role->forAll( role | boundRoles->includes(role) ) and (connector.type->notEmpty() and correspondingConnector.type->notEmpty()) implies connector.type->forAll(conformsTo(correspondingConnector.type)) ) )
class Connector 
invariant types
type<>null implies let noOfEnds : Integer = end->size() in (type.memberEnd->size() = noOfEnds) and Sequence{noOfEnds}->forAll(i | end->at(i).role.type.conformsTo(type.memberEnd->at(i).type))
invariant roles
structuredClassifier <> null and end->forAll( e | structuredClassifier.allRoles()->includes(e.role) or e.role.oclIsKindOf(Port) and structuredClassifier.allRoles()->includes(e.partWithPort))
class GeneralizationSet 
invariant generalization_same_classifier
generalization->collect(general)->asSet()->size() <= 1
invariant maps_to_generalization_set 
powertype <> null implies generalization->forAll( gen | not (gen.general = powertype) and not gen.general.allParents()->includes(powertype) and not (gen.specific = powertype) and not powertype.allParents()->includes(gen.specific) )
class RedefinableTemplateSignature
invariant redefines_parents
classifier.allParents()->forAll(c | c.ownedTemplateSignature->notEmpty() implies self->closure(extendedSignature)->includes(c.ownedTemplateSignature))
class UseCase
invariant binary_associations
Association.allInstances()->forAll(a | a.memberEnd.type->includes(self) implies a.memberEnd->size() = 2)
invariant no_association_to_use_case
Association.allInstances()->forAll(a | a.memberEnd.type->includes(self) implies ( let usecases: Set(UseCase) = a.memberEnd.type->select(oclIsKindOf(UseCase))->collect(oclAsType(UseCase))->asSet() in usecases->size() > 1 implies usecases->collect(subject)->size() > 1 ) )
invariant cannot_include_self 
not allIncludedUseCases()->includes(self)
invariant must_have_name 
name -> notEmpty ()
class Extend 
invariant extension_points 
extensionLocation->forAll (xp | extendedCase.extensionPoint->includes(xp))
class ExtensionPoint 
invariant must_have_name 
name->notEmpty ()
class ClassifierTemplateParameter 
invariant has_constraining_classifier 
allowSubstitutable implies constrainingClassifier->notEmpty()
invariant parametered_element_no_features
parameteredElement.feature->isEmpty() and (constrainingClassifier->isEmpty() implies parameteredElement.allParents()->isEmpty())
invariant matching_abstract
(not parameteredElement.isAbstract) implies templateParameterSubstitution.actual->forAll(a | not a.oclAsType(Classifier).isAbstract)
invariant actual_is_classifier
templateParameterSubstitution.actual->forAll(a | a.oclIsKindOf(Classifier))
invariant constraining_classifiers_constrain_args
templateParameterSubstitution.actual->forAll( a | let arg : Classifier = a.oclAsType(Classifier) in constrainingClassifier->forAll( cc | arg = cc or arg.conformsTo(cc) or (allowSubstitutable and arg.isSubstitutableFor(cc)) ) )
invariant constraining_classifiers_constrain_parametered_element
constrainingClassifier->forAll( cc | parameteredElement = cc or parameteredElement.conformsTo(cc) or (allowSubstitutable and parameteredElement.isSubstitutableFor(cc)) )
class ActivityGroup 
invariant nodes_and_edges 
containedNode->forAll(activity = self.containingActivity()) and containedEdge->forAll(activity = self.containingActivity())
invariant not_contained
subgroup->closure(subgroup).containedNode->excludesAll(containedNode) and superGroup->closure(superGroup).containedNode->excludesAll(containedNode) and subgroup->closure(subgroup).containedEdge->excludesAll(containedEdge) and superGroup->closure(superGroup).containedEdge->excludesAll(containedEdge)
class ActivityEdge 
invariant source_and_target 
activity<>null implies source.containingActivity() = activity and target.containingActivity() = activity
class ActivityPartition 
invariant represents_classifier
(not isExternal and represents.oclIsKindOf(Classifier) and superPartition->notEmpty()) implies ( let representedClassifier : Classifier = represents.oclAsType(Classifier) in superPartition.represents.oclIsKindOf(Classifier) and let representedSuperClassifier : Classifier = superPartition.represents.oclAsType(Classifier) in (representedSuperClassifier.oclIsKindOf(BehavioredClassifier) and representedClassifier.oclIsKindOf(Behavior) and representedSuperClassifier.oclAsType(BehavioredClassifier).ownedBehavior->includes(representedClassifier.oclAsType(Behavior))) or (representedSuperClassifier.oclIsKindOf(Class) and representedSuperClassifier.oclAsType(Class).nestedClassifier->includes(representedClassifier)) or (Association.allInstances()->exists(a | a.memberEnd->exists(end1 | end1.isComposite and end1.type = representedClassifier and a.memberEnd->exists(end2 | end1<>end2 and end2.type = representedSuperClassifier)))) )
invariant represents_property_and_is_contained 
(represents.oclIsKindOf(Property) and superPartition->notEmpty()) implies ( (superPartition.represents.oclIsKindOf(Classifier) and represents.owner = superPartition.represents) or (superPartition.represents.oclIsKindOf(Property) and represents.owner = superPartition.represents.oclAsType(Property).type) )
invariant represents_property 
(represents.oclIsKindOf(Property) and superPartition->notEmpty() and superPartition.represents.oclIsKindOf(Classifier)) implies ( let representedClassifier : Classifier = superPartition.represents.oclAsType(Classifier) in superPartition.subpartition->reject(isExternal)->forAll(p | p.represents.oclIsKindOf(Property) and p.owner=representedClassifier) )
invariant dimension_not_contained 
isDimension implies superPartition->isEmpty()
class InterruptibleActivityRegion
invariant interrupting_edges 
interruptingEdge->forAll(edge | node->includes(edge.source) and node->excludes(edge.target) and edge.target.containingActivity() = inActivity)
class StructuredActivityNode 
invariant output_pin_edges
output.outgoing.target->excludesAll(allOwnedNodes()-input)
invariant edges
edge=self.sourceNodes().outgoing->intersection(self.allOwnedNodes().incoming)-> union(self.targetNodes().incoming->intersection(self.allOwnedNodes().outgoing))->asSet()
invariant input_pin_edges
input.incoming.source->excludesAll(allOwnedNodes()-output)
class ExceptionHandler 
invariant handler_body_edges 
handlerBody.incoming->isEmpty() and handlerBody.outgoing->isEmpty() and exceptionInput.incoming->isEmpty()
invariant output_pins
(protectedNode.oclIsKindOf(Action) and protectedNode.oclAsType(Action).output->notEmpty()) implies ( handlerBody.oclIsKindOf(Action) and let protectedNodeOutput : OrderedSet(OutputPin) = protectedNode.oclAsType(Action).output, handlerBodyOutput : OrderedSet(OutputPin) = handlerBody.oclAsType(Action).output in protectedNodeOutput->size() = handlerBodyOutput->size() and Sequence{protectedNodeOutput->size()}->forAll(i | handlerBodyOutput->at(i).type.conformsTo(protectedNodeOutput->at(i).type) and handlerBodyOutput->at(i).isOrdered=protectedNodeOutput->at(i).isOrdered and handlerBodyOutput->at(i).compatibleWith(protectedNodeOutput->at(i))) )
invariant one_input
handlerBody.oclIsKindOf(Action) and let inputs: OrderedSet(InputPin) = handlerBody.oclAsType(Action).input in inputs->size()=1 and inputs->first()=exceptionInput
invariant edge_source_target
let nodes:Set(ActivityNode) = handlerBody.oclAsType(Action).allOwnedNodes() in nodes.outgoing->forAll(nodes->includes(target)) and nodes.incoming->forAll(nodes->includes(source))
invariant handler_body_owner 
handlerBody.owner=protectedNode.owner
invariant exception_input_type
exceptionInput.type=null or exceptionType->forAll(conformsTo(exceptionInput.type.oclAsType(Classifier)))
class ObjectNode
invariant input_output_parameter
selection<>null implies selection.inputParameters()->size()=1 and selection.inputParameters()->forAll(p | not p.isUnique and p.is(0,*) and self.type.conformsTo(p.type)) and selection.outputParameters()->size()=1 and selection.inputParameters()->forAll(p | self.type.conformsTo(p.type))
invariant selection_behavior 
(selection<>null) = (ordering=ObjectNodeOrderingKind::ordered)
invariant object_flow_edges 
(not isControlType) implies incoming->union(outgoing)->forAll(oclIsKindOf(ObjectFlow))
class InputPin 
invariant outgoing_edges_structured_only 
outgoing->notEmpty() implies action<>null and action.oclIsKindOf(StructuredActivityNode) and action.oclAsType(StructuredActivityNode).allOwnedNodes()->includesAll(outgoing.target)
class Pin 
invariant control_pins 
isControl implies isControlType
invariant not_unique 
not isUnique
class OutputPin 
invariant incoming_edges_structured_only
incoming->notEmpty() implies action<>null and action.oclIsKindOf(StructuredActivityNode) and action.oclAsType(StructuredActivityNode).allOwnedNodes()->includesAll(incoming.source)
class ValueSpecificationAction 
invariant multiplicity 
result.is(1,1)
invariant compatible_type 
value.type.conformsTo(result.type)
class VariableAction 
invariant scope_of_variable 
variable.isAccessibleBy(self)
class WriteLinkAction 
invariant allow_access
endData.end->exists(end | end.type=_'' or end.visibility=VisibilityKind::public or end.visibility=VisibilityKind::protected and endData.end->exists(other | other<>end and _''.conformsTo(other.type.oclAsType(Classifier))))
class LinkAction 
invariant same_pins 
inputValue->asBag()=endData.allPins()
invariant same_association 
endData.end = self.association().memberEnd->asBag()
invariant not_static 
endData->forAll(not end.isStatic)
class LinkEndData 
invariant same_type 
value<>null implies value.type.conformsTo(end.type)
invariant multiplicity 
value<>null implies value.is(1,1)
invariant end_object_input_pin 
value->excludesAll(qualifier.value)
invariant property_is_association_end 
end.association <> null
invariant qualifiers 
end.qualifier->includesAll(qualifier.qualifier)
class QualifierValue 
invariant multiplicity_of_qualifier 
value.is(1,1)
invariant type_of_qualifier 
value.type.conformsTo(qualifier.type)
invariant qualifier_attribute
linkEndData.end.qualifier->includes(qualifier)
class WriteStructuralFeatureAction 
invariant multiplicity_of_result 
result <> null implies result.is(1,1)
invariant type_of_value 
value <> null implies value.type.conformsTo(structuralFeature.type)
invariant multiplicity_of_value 
value<>null implies value.is(1,1)
invariant type_of_result 
result <> null implies result.type = .type
class StructuralFeatureAction 
invariant multiplicity 
.is(1,1)
invariant object_type 
.type.oclAsType(Classifier).allFeatures()->includes(structuralFeature) or .type.conformsTo(structuralFeature.oclAsType(Property).opposite.type)
invariant visibility 
structuralFeature.visibility = VisibilityKind::public or _''.allFeatures()->includes(structuralFeature) or structuralFeature.visibility=VisibilityKind::protected and _''.conformsTo(structuralFeature.oclAsType(Property).opposite.type.oclAsType(Classifier))
invariant not_static 
not structuralFeature.isStatic
invariant one_featuring_classifier
structuralFeature.featuringClassifier->size() = 1
class WriteVariableAction 
invariant value_type 
value <> null implies value.type.conformsTo(variable.type)
invariant multiplicity 
value<>null implies value.is(1,1)
class AcceptCallAction 
invariant result_pins
let parameter: OrderedSet(Parameter) = trigger.event->asSequence()->first().oclAsType(CallEvent).operation.inputParameters() in result->size() = parameter->size() and Sequence{result->size()}->forAll(i | parameter->at(i).type.conformsTo(result->at(i).type) and parameter->at(i).isOrdered = result->at(i).isOrdered and parameter->at(i).compatibleWith(result->at(i)))
invariant trigger_call_event
trigger->size()=1 and trigger->asSequence()->first().event.oclIsKindOf(CallEvent)
invariant unmarshall 
isUnmarshall = true
class AcceptEventAction 
invariant one_output_pin
not isUnmarshall and trigger->exists(event.oclIsKindOf(SignalEvent) or event.oclIsKindOf(TimeEvent)) implies output->size() = 1 and output->first().is(1,1)
invariant no_input_pins
input->size() = 0
invariant no_output_pins
(self.oclIsTypeOf(AcceptEventAction) and (trigger->forAll(event.oclIsKindOf(ChangeEvent) or event.oclIsKindOf(CallEvent)))) implies output->size() = 0
invariant unmarshall_signal_events
isUnmarshall and self.oclIsTypeOf(AcceptEventAction) implies trigger->size()=1 and trigger->asSequence()->first().event.oclIsKindOf(SignalEvent) and let attribute: OrderedSet(Property) = trigger->asSequence()->first().event.oclAsType(SignalEvent).signal.allAttributes() in attribute->size()>0 and result->size() = attribute->size() and Sequence{result->size()}->forAll(i | result->at(i).type = attribute->at(i).type and result->at(i).isOrdered = attribute->at(i).isOrdered and result->at(i).includesMultiplicity(attribute->at(i)))
invariant conforming_type
not isUnmarshall implies result->isEmpty() or let type: Type = result->first().type in type=null or (trigger->forAll(event.oclIsKindOf(SignalEvent)) and trigger.event.oclAsType(SignalEvent).signal->forAll(s | s.conformsTo(type)))
class ActionInputPin 
invariant input_pin 
fromAction.input->forAll(oclIsKindOf(ActionInputPin))
invariant one_output_pin
fromAction.output->size() = 1
invariant no_control_or_object_flow 
fromAction.incoming->union(outgoing)->isEmpty() and fromAction.input.incoming->isEmpty() and fromAction.output.outgoing->isEmpty()
class AddStructuralFeatureValueAction 
invariant required_value 
value<>null
invariant insertAt_pin
if not structuralFeature.isOrdered then insertAt = null else not isReplaceAll implies insertAt<>null and insertAt->forAll(type=UnlimitedNatural and is(1,1.oclAsType(UnlimitedNatural))) endif
class AddVariableValueAction 
invariant required_value 
value <> null
invariant insertAt_pin 
if not variable.isOrdered then insertAt = null else not isReplaceAll implies insertAt<>null and insertAt->forAll(type=UnlimitedNatural and is(1,1.oclAsType(UnlimitedNatural))) endif
class BroadcastSignalAction 
invariant number_of_arguments 
argument->size() = signal.allAttributes()->size()
invariant type_ordering_multiplicity
let attribute: OrderedSet(Property) = signal.allAttributes() in Sequence{argument->size()}->forAll(i | argument->at(i).type.conformsTo(attribute->at(i).type) and argument->at(i).isOrdered = attribute->at(i).isOrdered and argument->at(i).compatibleWith(attribute->at(i)))
invariant no_onport 
onPort=null
class CallAction 
invariant argument_pins
let parameter: OrderedSet(Parameter) = self.inputParameters() in argument->size() = parameter->size() and Sequence{argument->size()}->forAll(i | argument->at(i).type.conformsTo(parameter->at(i).type) and argument->at(i).isOrdered = parameter->at(i).isOrdered and argument->at(i).compatibleWith(parameter->at(i)))
invariant result_pins
let parameter: OrderedSet(Parameter) = self.outputParameters() in result->size() = parameter->size() and Sequence{result->size()}->forAll(i | parameter->at(i).type.conformsTo(result->at(i).type) and parameter->at(i).isOrdered = result->at(i).isOrdered and parameter->at(i).compatibleWith(result->at(i)))
invariant synchronous_call 
result->notEmpty() implies isSynchronous
class CallBehaviorAction 
invariant no_onport 
onPort=null
class CallOperationAction 
invariant type_target_pin 
if onPort=null then target.type.oclAsType(Classifier).allFeatures()->includes(operation) else target.type.oclAsType(Classifier).allFeatures()->includes(onPort) and onPort.provided->union(onPort.required).allFeatures()->includes(operation) endif
class Clause 
invariant body_output_pins 
_'body'.oclAsType(Action).allActions().output->includesAll(bodyOutput)
invariant decider_output 
test.oclAsType(Action).allActions().output->includes(decider) and decider.type = Boolean and decider.is(1,1)
invariant test_and_body 
test->intersection(_'body')->isEmpty()
class ClearAssociationAction 
invariant multiplicity 
.is(1,1)
invariant same_type 
association.memberEnd->exists(self..type.conformsTo(type))
class ClearStructuralFeatureAction 
invariant type_of_result 
result<>null implies result.type = .type
invariant multiplicity_of_result 
result<>null implies result.is(1,1)
class ConditionalNode 
invariant result_no_incoming 
result.incoming->isEmpty()
invariant no_input_pins 
input->isEmpty()
invariant one_clause_with_executable_node 
node->select(oclIsKindOf(ExecutableNode)).oclAsType(ExecutableNode)->forAll(n | self.clause->select(test->union(_'body')->includes(n))->size()=1)
invariant matching_output_pins 
clause->forAll( bodyOutput->size()=self.result->size() and Sequence{self.result->size()}->forAll(i | bodyOutput->at(i).type.conformsTo(result->at(i).type) and bodyOutput->at(i).isOrdered = result->at(i).isOrdered and bodyOutput->at(i).isUnique = result->at(i).isUnique and bodyOutput->at(i).compatibleWith(result->at(i))))
invariant executable_nodes 
clause.test->union(clause._'body') = node->select(oclIsKindOf(ExecutableNode)).oclAsType(ExecutableNode)
invariant clause_no_predecessor 
clause->closure(predecessorClause)->intersection(clause)->isEmpty()
class CreateLinkAction 
invariant association_not_abstract 
not self.association().isAbstract
class LinkEndCreationData 
invariant insertAt_pin 
if not end.isOrdered then insertAt = null else not isReplaceAll=false implies insertAt <> null and insertAt->forAll(type=UnlimitedNatural and is(1,1)) endif
class CreateLinkObjectAction 
invariant multiplicity 
result.is(1,1)
invariant type_of_result 
result.type = association()
invariant association_class 
self.association().oclIsKindOf(AssociationClass)
class CreateObjectAction
invariant classifier_not_abstract 
not classifier.isAbstract
invariant multiplicity 
result.is(1,1)
invariant classifier_not_association_class 
not classifier.oclIsKindOf(AssociationClass)
invariant same_type 
result.type = classifier
class LinkEndDestructionData 
invariant destroyAt_pin 
if not end.isOrdered or end.isUnique or isDestroyDuplicates then destroyAt = null else destroyAt <> null and destroyAt->forAll(type=UnlimitedNatural and is(1,1)) endif
class DestroyObjectAction 
invariant multiplicity 
target.is(1,1)
invariant no_type 
target.type= null
class ExpansionNode 
invariant region_as_input_or_output 
regionAsInput->notEmpty() xor regionAsOutput->notEmpty()
class LoopNode 
invariant result_no_incoming 
result.incoming->isEmpty()
invariant input_edges 
loopVariableInput.outgoing->isEmpty()
invariant executable_nodes 
setupPart->union(test)->union(bodyPart)=node->select(oclIsKindOf(ExecutableNode)).oclAsType(ExecutableNode)->asSet()
invariant body_output_pins 
bodyPart.oclAsType(Action).allActions().output->includesAll(bodyOutput)
invariant setup_test_and_body 
setupPart->intersection(test)->isEmpty() and setupPart->intersection(bodyPart)->isEmpty() and test->intersection(bodyPart)->isEmpty()
invariant matching_output_pins 
bodyOutput->size()=loopVariable->size() and Sequence{loopVariable->size()}->forAll(i | bodyOutput->at(i).type.conformsTo(loopVariable->at(i).type) and bodyOutput->at(i).isOrdered = loopVariable->at(i).isOrdered and bodyOutput->at(i).isUnique = loopVariable->at(i).isUnique and loopVariable->at(i).includesMultiplicity(bodyOutput->at(i)))
invariant matching_loop_variables 
loopVariableInput->size()=loopVariable->size() and loopVariableInput.type=loopVariable.type and loopVariableInput.isUnique=loopVariable.isUnique and loopVariableInput.lower=loopVariable.lower and loopVariableInput.upper=loopVariable.upper
invariant matching_result_pins 
result->size()=loopVariable->size() and result.type=loopVariable.type and result.isUnique=loopVariable.isUnique and result.lower=loopVariable.lower and result.upper=loopVariable.upper
invariant loop_variable_outgoing 
allOwnedNodes()->includesAll(loopVariable.outgoing.target)
class OpaqueAction 
invariant language_body_size 
language->notEmpty() implies (_'body'->size() = language->size())
class ReadExtentAction 
invariant type_is_classifier 
result.type = classifier
invariant multiplicity_of_result 
result.is(0,*)
class ReadIsClassifiedObjectAction 
invariant no_type 
.type = null
invariant multiplicity_of_output 
result.is(1,1)
invariant boolean_result 
result.type = Boolean
invariant multiplicity_of_input 
.is(1,1)
class ReadLinkAction 
invariant type_and_ordering 
self.openEnd()->forAll(type=result.type and isOrdered=result.isOrdered)
invariant compatible_multiplicity 
self.openEnd()->first().compatibleWith(result)
invariant visibility 
let openEnd : Property = self.openEnd()->first() in openEnd.visibility = VisibilityKind::public or endData->exists(oed | oed.end<>openEnd and (_'' = oed.end.type or (openEnd.visibility = VisibilityKind::protected and _''.conformsTo(oed.end.type.oclAsType(Classifier)))))
invariant one_open_end 
self.openEnd()->size() = 1
invariant navigable_open_end 
self.openEnd()->first().isNavigable()
class ReadLinkObjectEndAction 
invariant property 
end.association <> null
invariant multiplicity_of_object 
.is(1,1)
invariant ends_of_association 
end.association.memberEnd->forAll(e | not e.isStatic)
invariant type_of_result 
result.type = end.type
invariant multiplicity_of_result 
result.is(1,1)
invariant type_of_object 
.type = end.association
invariant association_of_association 
end.association.oclIsKindOf(AssociationClass)
class ReadLinkObjectEndQualifierAction 
invariant multiplicity_of_object 
.is(1,1)
invariant type_of_object 
.type = qualifier.associationEnd.association
invariant multiplicity_of_qualifier 
qualifier.is(1,1)
invariant ends_of_association 
qualifier.associationEnd.association.memberEnd->forAll(e | not e.isStatic)
invariant multiplicity_of_result 
result.is(1,1)
invariant same_type 
result.type = qualifier.type
invariant association_of_association 
qualifier.associationEnd.association.oclIsKindOf(AssociationClass)
invariant qualifier_attribute 
qualifier.associationEnd <> null
class ReadSelfAction 
invariant contained 
_'' <> null
invariant multiplicity 
result.is(1,1)
invariant not_static 
let behavior: Behavior = self.containingBehavior() in behavior.specification<>null implies not behavior.specification.isStatic
invariant type 
result.type = _''
class ReadStructuralFeatureAction 
invariant multiplicity 
structuralFeature.compatibleWith(result)
invariant type_and_ordering 
result.type =structuralFeature.type and result.isOrdered = structuralFeature.isOrdered
class ReadVariableAction 
invariant type_and_ordering 
result.type =variable.type and result.isOrdered = variable.isOrdered
invariant compatible_multiplicity 
variable.compatibleWith(result)
class ReclassifyObjectAction 
invariant input_pin 
.type = null
invariant classifier_not_abstract 
not newClassifier->exists(isAbstract)
invariant multiplicity 
.is(1,1)
class ReduceAction 
invariant reducer_inputs_output 
let inputs: OrderedSet(Parameter) = reducer.inputParameters() in let outputs: OrderedSet(Parameter) = reducer.outputParameters() in inputs->size()=2 and outputs->size()=1 and inputs.type->forAll(t | outputs.type->forAll(conformsTo(t)) and -- Note that the following only checks the case when the collection is via multiple tokens. collection.upperBound()>1 implies collection.type.conformsTo(t))
invariant input_type_is_collection 
invariant output_types_are_compatible 
reducer.outputParameters().type->forAll(conformsTo(result.type))
class RemoveStructuralFeatureValueAction 
invariant removeAt_and_value 
if structuralFeature.isOrdered and not structuralFeature.isUnique and not isRemoveDuplicates then value = null and removeAt <> null and removeAt.type = UnlimitedNatural and removeAt.is(1,1) else removeAt = null and value <> null endif
class RemoveVariableValueAction 
invariant removeAt_and_value 
if variable.isOrdered and not variable.isUnique and not isRemoveDuplicates then value = null and removeAt <> null and removeAt.type = UnlimitedNatural and removeAt.is(1,1) else removeAt = null and value <> null endif
class ReplyAction 
invariant pins_match_parameter 
let parameter:OrderedSet(Parameter) = replyToCall.event.oclAsType(CallEvent).operation.outputParameters() in replyValue->size()=parameter->size() and Sequence{replyValue->size()}->forAll(i | replyValue->at(i).type.conformsTo(parameter->at(i).type) and replyValue->at(i).isOrdered=parameter->at(i).isOrdered and replyValue->at(i).compatibleWith(parameter->at(i)))
invariant event_on_reply_to_call_trigger 
replyToCall.event.oclIsKindOf(CallEvent)
class SendObjectAction 
invariant type_target_pin 
onPort<>null implies target.type.oclAsType(Classifier).allFeatures()->includes(onPort)
class SendSignalAction 
invariant type_ordering_multiplicity 
let attribute: OrderedSet(Property) = signal.allAttributes() in Sequence{argument->size()}->forAll(i | argument->at(i).type.conformsTo(attribute->at(i).type) and argument->at(i).isOrdered = attribute->at(i).isOrdered and argument->at(i).compatibleWith(attribute->at(i)))
invariant number_order 
argument->size()=signal.allAttributes()->size()
invariant type_target_pin 
not onPort->isEmpty() implies target.type.oclAsType(Classifier).allFeatures()->includes(onPort)
class StartClassifierBehaviorAction 
invariant multiplicity 
.is(1,1)
invariant type_has_classifier 
.type->notEmpty() implies (.type.oclIsKindOf(BehavioredClassifier) and .type.oclAsType(BehavioredClassifier).classifierBehavior<>null)
class StartObjectBehaviorAction 
invariant multiplicity_of_object 
.is(1,1)
invariant type_of_object 
self.behavior()<>null
invariant no_onport 
onPort->isEmpty()
class TestIdentityAction 
invariant multiplicity 
first.is(1,1) and second.is(1,1)
invariant no_type 
first.type= null and second.type = null
invariant result_is_boolean 
result.type=Boolean
class UnmarshallAction 
invariant structural_feature 
unmarshallType.allAttributes()->size() >= 1
class ValuePin 
invariant no_incoming_edges 
incoming->isEmpty()
invariant compatible_type 
value.type.conformsTo(type)
class FinalNode 
invariant no_outgoing_edges 
outgoing->isEmpty()
class ActivityParameterNode 
invariant no_outgoing_edges 
(incoming->notEmpty() and outgoing->isEmpty()) implies (parameter.direction = ParameterDirectionKind::out or parameter.direction = ParameterDirectionKind::inout or parameter.direction = ParameterDirectionKind::return)
invariant has_parameters 
activity.ownedParameter->includes(parameter)
invariant same_type 
type = parameter.type
invariant no_incoming_edges 
(outgoing->notEmpty() and incoming->isEmpty()) implies (parameter.direction = ParameterDirectionKind::_'in' or parameter.direction = ParameterDirectionKind::inout)
invariant no_edges 
incoming->isEmpty() or outgoing->isEmpty()
class ControlFlow 
invariant object_nodes 
(source.oclIsKindOf(ObjectNode) implies source.oclAsType(ObjectNode).isControlType) and (target.oclIsKindOf(ObjectNode) implies target.oclAsType(ObjectNode).isControlType)
class DecisionNode 
invariant zero_input_parameters 
(decisionInput<>null and decisionInputFlow=null and incoming->exists(oclIsKindOf(ControlFlow))) implies decisionInput.inputParameters()->isEmpty()
invariant edges 
let allEdges: Set(ActivityEdge) = incoming->union(outgoing) in let allRelevantEdges: Set(ActivityEdge) = if decisionInputFlow->notEmpty() then allEdges->excluding(decisionInputFlow) else allEdges endif in allRelevantEdges->forAll(oclIsKindOf(ControlFlow)) or allRelevantEdges->forAll(oclIsKindOf(ObjectFlow))
invariant decision_input_flow_incoming 
incoming->includes(decisionInputFlow)
invariant two_input_parameters 
(decisionInput<>null and decisionInputFlow<>null and incoming->forAll(oclIsKindOf(ObjectFlow))) implies decisionInput.inputParameters()->size()=2
invariant incoming_outgoing_edges 
(incoming->size() = 1 or incoming->size() = 2) and outgoing->size() > 0
invariant incoming_control_one_input_parameter
(decisionInput<>null and decisionInputFlow<>null and incoming->exists(oclIsKindOf(ControlFlow))) implies decisionInput.inputParameters()->size()=1
invariant parameters 
decisionInput<>null implies (decisionInput.ownedParameter->forAll(par | par.direction <> ParameterDirectionKind::out and par.direction <> ParameterDirectionKind::inout ) and decisionInput.ownedParameter->one(par | par.direction <> ParameterDirectionKind::return))
invariant incoming_object_one_input_parameter
(decisionInput<>null and decisionInputFlow=null and incoming->forAll(oclIsKindOf(ObjectFlow))) implies decisionInput.inputParameters()->size()=1
class ObjectFlow 
invariant input_and_output_parameter
selection<>null implies selection.inputParameters()->size()=1 and selection.inputParameters()->forAll(not isUnique and is(0,*)) and selection.outputParameters()->size()=1
invariant no_executable_nodes 
not (source.oclIsKindOf(ExecutableNode) or target.oclIsKindOf(ExecutableNode))
invariant transformation_behavior
transformation<>null implies transformation.inputParameters()->size()=1 and transformation.outputParameters()->size()=1
invariant selection_behavior 
selection<>null implies source.oclIsKindOf(ObjectNode)
invariant compatible_types 
invariant same_upper_bounds 
invariant target 
invariant is_multicast_or_is_multireceive 
not (isMulticast and isMultireceive)
class ForkNode 
invariant edges 
let allEdges : Set(ActivityEdge) = incoming->union(outgoing) in allEdges->forAll(oclIsKindOf(ControlFlow)) or allEdges->forAll(oclIsKindOf(ObjectFlow))
invariant one_incoming_edge 
incoming->size()=1
class InitialNode 
invariant no_incoming_edges 
incoming->isEmpty()
invariant control_edges 
outgoing->forAll(oclIsKindOf(ControlFlow))
class JoinNode 
invariant one_outgoing_edge 
outgoing->size() = 1
invariant incoming_object_flow 
if incoming->exists(oclIsKindOf(ObjectFlow)) then outgoing->forAll(oclIsKindOf(ObjectFlow)) else outgoing->forAll(oclIsKindOf(ControlFlow)) endif
class MergeNode 
invariant one_outgoing_edge 
outgoing->size()=1
invariant edges 
let allEdges : Set(ActivityEdge) = incoming->union(outgoing) in allEdges->forAll(oclIsKindOf(ControlFlow)) or allEdges->forAll(oclIsKindOf(ObjectFlow))
class FunctionBehavior 
invariant one_output_parameter 
self.ownedParameter-> select(p | p.direction = ParameterDirectionKind::out or p.direction= ParameterDirectionKind::inout or p.direction= ParameterDirectionKind::return)->size() >= 1
invariant types_of_parameters 
ownedParameter->forAll(p | p.type <> null and p.type.oclIsTypeOf(DataType) and hasAllDataTypeAttributes(p.type.oclAsType(DataType)))
class TimeEvent 
invariant when_non_negative 
when.integerValue() >= 0
class TimeExpression 
invariant no_expr_requires_observation 
expr = null implies (observation->size() = 1 and observation->forAll(oclIsKindOf(TimeObservation)))
class CommunicationPath 
invariant association_ends 
endType->forAll (oclIsKindOf(DeploymentTarget))
class Node 
invariant internal_structure 
part->forAll(oclIsKindOf(Node))
class InformationFlow 
invariant must_conform 
invariant sources_and_targets_kind 
Behavior and InstanceSpecification except when its classifier is a relationship (i.e. it represents a link). (self.informationSource->forAll( sis | oclIsKindOf(Actor) or oclIsKindOf(Node) or oclIsKindOf(UseCase) or oclIsKindOf(Artifact) or oclIsKindOf(Class) or oclIsKindOf(Component) or oclIsKindOf(Port) or oclIsKindOf(Property) or oclIsKindOf(Interface) or oclIsKindOf(Package) or oclIsKindOf(ActivityNode) or oclIsKindOf(ActivityPartition) or (oclIsKindOf(InstanceSpecification) and not sis.oclAsType(InstanceSpecification).classifier->exists(oclIsKindOf(Relationship))))) and (self.informationTarget->forAll( sit | oclIsKindOf(Actor) or oclIsKindOf(Node) or oclIsKindOf(UseCase) or oclIsKindOf(Artifact) or oclIsKindOf(Class) or oclIsKindOf(Component) or oclIsKindOf(Port) or oclIsKindOf(Property) or oclIsKindOf(Interface) or oclIsKindOf(Package) or oclIsKindOf(ActivityNode) or oclIsKindOf(ActivityPartition) or (oclIsKindOf(InstanceSpecification) and not sit.oclAsType(InstanceSpecification).classifier->exists(oclIsKindOf(Relationship)))))
invariant convey_classifiers 
self.conveyed->forAll(oclIsKindOf(Class) or oclIsKindOf(Interface) or oclIsKindOf(InformationItem) or oclIsKindOf(Signal) or oclIsKindOf(Component))
class Message 
invariant sending_receiving_message_event 
receiveEvent.oclIsKindOf(MessageOccurrenceSpecification) implies let f : Lifeline = sendEvent->select(oclIsKindOf(MessageOccurrenceSpecification)).oclAsType(MessageOccurrenceSpecification)->asOrderedSet()->first().covered in f = receiveEvent->select(oclIsKindOf(MessageOccurrenceSpecification)).oclAsType(MessageOccurrenceSpecification)->asOrderedSet()->first().covered implies f.events->indexOf(sendEvent.oclAsType(MessageOccurrenceSpecification)->asOrderedSet()->first() ) < f.events->indexOf(receiveEvent.oclAsType(MessageOccurrenceSpecification)->asOrderedSet()->first() )
invariant arguments 
invariant cannot_cross_boundaries 
sendEvent->notEmpty() and receiveEvent->notEmpty() implies let sendEnclosingFrag : Set(InteractionFragment) = sendEvent->asOrderedSet()->first().enclosingFragment() in let receiveEnclosingFrag : Set(InteractionFragment) = receiveEvent->asOrderedSet()->first().enclosingFragment() in sendEnclosingFrag = receiveEnclosingFrag
invariant signature_is_signal 
(messageSort = MessageSort::asynchSignal ) and signature.oclIsKindOf(Signal) implies let signalAttributes : OrderedSet(Property) = signature.oclAsType(Signal).inheritedMember()-> select(n:NamedElement | n.oclIsTypeOf(Property))->collect(oclAsType(Property))->asOrderedSet() in signalAttributes->size() = self.argument->size() and self.argument->forAll( o: ValueSpecification | not (o.oclIsKindOf(Expression) and o.oclAsType(Expression).symbol->size()=0 and o.oclAsType(Expression).operand->isEmpty() ) implies let p : Property = signalAttributes->at(self.argument->indexOf(o)) in o.type.oclAsType(Classifier).conformsTo(p.type.oclAsType(Classifier)))
invariant occurrence_specifications 
invariant signature_refer_to 
signature->notEmpty() implies ((signature.oclIsKindOf(Operation) and (messageSort = MessageSort::asynchCall or messageSort = MessageSort::synchCall or messageSort = MessageSort::reply) ) or (signature.oclIsKindOf(Signal) and messageSort = MessageSort::asynchSignal ) ) and name = signature.name
invariant signature_is_operation_request 
(messageSort = MessageSort::asynchCall or messageSort = MessageSort::synchCall) and signature.oclIsKindOf(Operation) implies let requestParms : OrderedSet(Parameter) = signature.oclAsType(Operation).ownedParameter-> select(direction = ParameterDirectionKind::inout or direction = ParameterDirectionKind::_'in' ) in requestParms->size() = self.argument->size() and self.argument->forAll( o: ValueSpecification | not (o.oclIsKindOf(Expression) and o.oclAsType(Expression).symbol->size()=0 and o.oclAsType(Expression).operand->isEmpty() ) implies let p : Parameter = requestParms->at(self.argument->indexOf(o)) in o.type.oclAsType(Classifier).conformsTo(p.type.oclAsType(Classifier)) )
invariant signature_is_operation_reply 
(messageSort = MessageSort::reply) and signature.oclIsKindOf(Operation) implies let replyParms : OrderedSet(Parameter) = signature.oclAsType(Operation).ownedParameter-> select(direction = ParameterDirectionKind::inout or direction = ParameterDirectionKind::out or direction = ParameterDirectionKind::return) in replyParms->size() = self.argument->size() and self.argument->forAll( o: ValueSpecification | o.oclIsKindOf(Expression) and let e : Expression = o.oclAsType(Expression) in e.operand->notEmpty() implies let p : Parameter = replyParms->at(self.argument->indexOf(o)) in e.operand->asSequence()->first().type.oclAsType(Classifier).conformsTo(p.type.oclAsType(Classifier)) )
class Interaction 
invariant not_contained 
enclosingInteraction->isEmpty()
class Lifeline
invariant selector_specified 
self.selector->notEmpty() = (self.represents.oclIsKindOf(MultiplicityElement) and self.represents.oclAsType(MultiplicityElement).isMultivalued())
invariant interaction_uses_share_lifeline 
let intUses : Set(InteractionUse) = interaction.interactionUse in intUses->forAll ( iuse : InteractionUse | let usingInteraction : Set(Interaction) = iuse.enclosingInteraction->asSet() ->union( iuse.enclosingOperand.combinedFragment->asSet()->closure(enclosingOperand.combinedFragment).enclosingInteraction->asSet() ) in let peerUses : Set(InteractionUse) = usingInteraction.fragment->select(oclIsKindOf(InteractionUse)).oclAsType(InteractionUse)->asSet() ->union( usingInteraction.fragment->select(oclIsKindOf(CombinedFragment)).oclAsType(CombinedFragment)->asSet() ->closure(operand.fragment->select(oclIsKindOf(CombinedFragment)).oclAsType(CombinedFragment)).operand.fragment-> select(oclIsKindOf(InteractionUse)).oclAsType(InteractionUse)->asSet() )->excluding(iuse) in peerUses->forAll( peerUse : InteractionUse | peerUse.refersTo.lifeline->forAll( l : Lifeline | (l.represents = self.represents and ( self.selector.oclIsKindOf(LiteralString) implies l.selector.oclIsKindOf(LiteralString) and self.selector.oclAsType(LiteralString).value = l.selector.oclAsType(LiteralString).value ) and ( self.selector.oclIsKindOf(LiteralInteger) implies l.selector.oclIsKindOf(LiteralInteger) and self.selector.oclAsType(LiteralInteger).value = l.selector.oclAsType(LiteralInteger).value ) ) implies usingInteraction.lifeline->exists(represents = self.represents and ( self.selector.oclIsKindOf(LiteralString) implies l.selector.oclIsKindOf(LiteralString) and self.selector.oclAsType(LiteralString).value = l.selector.oclAsType(LiteralString).value ) and ( self.selector.oclIsKindOf(LiteralInteger) implies l.selector.oclIsKindOf(LiteralInteger) and self.selector.oclAsType(LiteralInteger).value = l.selector.oclAsType(LiteralInteger).value ) ) ) ) )
invariant same_classifier 
represents.namespace->closure(namespace)->includes(interaction._'')
invariant selector_int_or_string 
self.selector->notEmpty() implies self.selector.oclIsKindOf(LiteralInteger) or self.selector.oclIsKindOf(LiteralString)
class PartDecomposition 
invariant commutativity_of_decomposition 
invariant assume 
invariant parts_of_internal_structures 
class InteractionUse 
invariant gates_match 
actualGate->notEmpty() implies refersTo.formalGate->forAll( fg : Gate | self.actualGate->select(matches(fg))->size()=1) and self.actualGate->forAll(ag : Gate | refersTo.formalGate->select(matches(ag))->size()=1)
invariant arguments_are_constants 
invariant returnValueRecipient_coverage 
returnValueRecipient->asSet()->notEmpty() implies let covCE : Set(ConnectableElement) = covered.represents->asSet() in covCE->notEmpty() and let classes:Set(Classifier) = covCE.type.oclIsKindOf(Classifier).oclAsType(Classifier)->asSet() in let allProps : Set(Property) = classes.attribute->union(classes.allParents().attribute)->asSet() in allProps->includes(returnValueRecipient)
invariant arguments_correspond_to_parameters 
invariant returnValue_type_recipient_correspondence 
returnValue.type->asSequence()->notEmpty() implies returnValue.type->asSequence()->first() = returnValueRecipient.type->asSequence()->first()
invariant all_lifelines 
let parentInteraction : Set(Interaction) = enclosingInteraction->asSet()-> union(enclosingOperand.combinedFragment->closure(enclosingOperand.combinedFragment)-> collect(enclosingInteraction).oclAsType(Interaction)->asSet()) in parentInteraction->size()=1 and let refInteraction : Interaction = refersTo in parentInteraction.covered-> forAll(intLifeline : Lifeline | refInteraction.covered-> forAll( refLifeline : Lifeline | refLifeline.represents = intLifeline.represents and ( ( refLifeline.selector.oclIsKindOf(LiteralString) implies intLifeline.selector.oclIsKindOf(LiteralString) and refLifeline.selector.oclAsType(LiteralString).value = intLifeline.selector.oclAsType(LiteralString).value ) and ( refLifeline.selector.oclIsKindOf(LiteralInteger) implies intLifeline.selector.oclIsKindOf(LiteralInteger) and refLifeline.selector.oclAsType(LiteralInteger).value = intLifeline.selector.oclAsType(LiteralInteger).value ) ) implies self.covered->asSet()->includes(intLifeline)))
class Gate 
invariant actual_gate_matched 
interactionUse->notEmpty() implies interactionUse.refersTo.formalGate->select(matches(self))->size()=1
invariant inside_cf_matched 
isInsideCF() implies combinedFragment.cfragmentGate->select(isOutsideCF() and matches(self))->size()=1
invariant outside_cf_matched 
isOutsideCF() implies if self.combinedFragment.interactionOperator->asOrderedSet()->first() = InteractionOperatorKind::alt then self.combinedFragment.operand->forAll(op : InteractionOperand | self.combinedFragment.cfragmentGate->select(isInsideCF() and oppositeEnd().enclosingFragment()->includes(self.combinedFragment) and matches(self))->size()=1) else self.combinedFragment.cfragmentGate->select(isInsideCF() and matches(self))->size()=1 endif
invariant formal_gate_distinguishable 
isFormal() implies interaction.formalGate->select(getName() = self.getName())->size()=1
invariant actual_gate_distinguishable 
isActual() implies interactionUse.actualGate->select(getName() = self.getName())->size()=1
invariant outside_cf_gate_distinguishable 
isOutsideCF() implies combinedFragment.cfragmentGate->select(getName() = self.getName())->size()=1
invariant inside_cf_gate_distinguishable 
isInsideCF() implies let selfOperand : InteractionOperand = self.getOperand() in combinedFragment.cfragmentGate->select(isInsideCF() and getName() = self.getName())->select(getOperand() = selfOperand)->size()=1
class InteractionOperand 
invariant guard_contain_references 
invariant guard_directly_prior 
class InteractionConstraint 
invariant minint_maxint 
maxint->notEmpty() or minint->notEmpty() implies interactionOperand.combinedFragment.interactionOperator = InteractionOperatorKind::loop
invariant minint_non_negative 
minint->notEmpty() implies minint->asSequence()->first().integerValue() >= 0
invariant maxint_positive 
maxint->notEmpty() implies maxint->asSequence()->first().integerValue() > 0
invariant dynamic_variables 
invariant global_data 
invariant maxint_greater_equal_minint 
maxint->notEmpty() implies (minint->notEmpty() and maxint->asSequence()->first().integerValue() >= minint->asSequence()->first().integerValue() )
class GeneralOrdering 
invariant irreflexive_transitive_closure 
after->closure(toAfter.after)->excludes(before)
class InformationItem 
invariant sources_and_targets 
(self.represented->select(oclIsKindOf(InformationItem))->forAll(p | p.conveyingFlow.source->forAll(q | self.conveyingFlow.source->includes(q)) and p.conveyingFlow.target->forAll(q | self.conveyingFlow.target->includes(q)))) and (self.represented->forAll(oclIsKindOf(Class) or oclIsKindOf(Interface) or oclIsKindOf(InformationItem) or oclIsKindOf(Signal) or oclIsKindOf(Component)))
invariant has_no 
self.generalization->isEmpty() and self.feature->isEmpty()
invariant not_instantiable 
isAbstract
class ActionExecutionSpecification 
invariant action_referenced 
(enclosingInteraction->notEmpty() or enclosingOperand.combinedFragment->notEmpty()) and let parentInteraction : Set(Interaction) = enclosingInteraction.oclAsType(Interaction)->asSet()->union( enclosingOperand.combinedFragment->closure(enclosingOperand.combinedFragment)-> collect(enclosingInteraction).oclAsType(Interaction)->asSet()) in (parentInteraction->size() = 1) and self.action.interaction->asSet() = parentInteraction
class ExecutionSpecification 
invariant same_lifeline 
start.covered = finish.covered
class CombinedFragment 
invariant break 
interactionOperator=InteractionOperatorKind::break implies enclosingInteraction.oclAsType(InteractionFragment)->asSet()->union( enclosingOperand.oclAsType(InteractionFragment)->asSet()).covered->asSet() = self.covered->asSet()
invariant consider_and_ignore 
((interactionOperator = InteractionOperatorKind::consider) or (interactionOperator = InteractionOperatorKind::ignore)) implies oclIsKindOf(ConsiderIgnoreFragment)
invariant opt_loop_break_neg 
(interactionOperator = InteractionOperatorKind::opt or interactionOperator = InteractionOperatorKind::loop or interactionOperator = InteractionOperatorKind::break or interactionOperator = InteractionOperatorKind::assert or interactionOperator = InteractionOperatorKind::neg) implies operand->size()=1
class ConsiderIgnoreFragment 
invariant consider_or_ignore 
(interactionOperator = InteractionOperatorKind::consider) or (interactionOperator = InteractionOperatorKind::ignore)
invariant type 
message->forAll(m | m.oclIsKindOf(Operation) or m.oclIsKindOf(Signal))
class Continuation 
invariant first_or_last_interaction_fragment 
enclosingOperand->notEmpty() and let peerFragments : OrderedSet(InteractionFragment) = enclosingOperand.fragment in ( peerFragments->notEmpty() and ((peerFragments->first() = self) or (peerFragments->last() = self)))
invariant same_name 
enclosingOperand.combinedFragment->notEmpty() and let parentInteraction : Set(Interaction) = enclosingOperand.combinedFragment->closure(enclosingOperand.combinedFragment)-> collect(enclosingInteraction).oclAsType(Interaction)->asSet() in (parentInteraction->size() = 1) and let peerInteractions : Set(Interaction) = (parentInteraction->union(parentInteraction->collect(_'')->collect(behavior)-> select(oclIsKindOf(Interaction)).oclAsType(Interaction)->asSet())->asSet()) in (peerInteractions->notEmpty()) and let combinedFragments1 : Set(CombinedFragment) = peerInteractions.fragment-> select(oclIsKindOf(CombinedFragment)).oclAsType(CombinedFragment)->asSet() in combinedFragments1->notEmpty() and combinedFragments1->closure(operand.fragment-> select(oclIsKindOf(CombinedFragment)).oclAsType(CombinedFragment))->asSet().operand.fragment-> select(oclIsKindOf(Continuation)).oclAsType(Continuation)->asSet()-> forAll(c : Continuation | (c.name = self.name) implies (c.covered->asSet()->forAll(cl : Lifeline | -- cl must be common to one lifeline covered by self self.covered->asSet()-> select(represents = cl.represents and selector = cl.selector)->asSet()->size()=1)) and (self.covered->asSet()->forAll(cl : Lifeline | -- cl must be common to one lifeline covered by c c.covered->asSet()-> select(represents = cl.represents and selector = cl.selector)->asSet()->size()=1)) )
invariant global 
enclosingOperand->notEmpty() and let operandLifelines : Set(Lifeline) = enclosingOperand.covered in (operandLifelines->notEmpty() and operandLifelines->forAll(ol :Lifeline |self.covered->includes(ol)))
class DestructionOccurrenceSpecification 
invariant no_occurrence_specifications_below 
let o : InteractionOperand = enclosingOperand in o->notEmpty() and let peerEvents : OrderedSet(OccurrenceSpecification) = covered.events->select(enclosingOperand = o) in peerEvents->last() = self
class FinalState 
invariant no_exit_behavior 
exit->isEmpty()
invariant no_outgoing_transitions 
outgoing->size() = 0
invariant no_regions 
region->size() = 0
invariant cannot_reference_submachine 
submachine->isEmpty()
invariant no_entry_behavior 
entry->isEmpty()
invariant no_state_behavior 
doActivity->isEmpty()
class ProtocolTransition 
invariant refers_to_operation 
if (referred()->notEmpty() and containingStateMachine()._''->notEmpty()) then containingStateMachine()._''.oclAsType(BehavioredClassifier).allFeatures()->includesAll(referred()) else true endif
invariant associated_actions 
effect = null
invariant belongs_to_psm 
container.belongsToPSM()
class AssociationClass 
invariant cannot_be_defined 
self.endType()->excludes(self) and self.endType()->collect(et|et.oclAsType(Classifier).allParents())->flatten()->excludes(self)
invariant disjoint_attributes_ends 
ownedAttribute->intersection(ownedEnd)->isEmpty()
class Component 
invariant no_nested_classifiers 
nestedClassifier->isEmpty()
invariant no_packaged_elements 
nestingClass <> null implies packagedElement->isEmpty()
class Actor 
invariant associations 
Association.allInstances()->forAll( a | a.memberEnd->collect(type)->includes(self) implies ( a.memberEnd->size() = 2 and let actorEnd : Property = a.memberEnd->any(type = self) in actorEnd.opposite.class.oclIsKindOf(UseCase) or ( actorEnd.opposite.class.oclIsKindOf(Class) and not actorEnd.opposite.class.oclIsKindOf(Behavior)) ) )
invariant must_have_name 
name->notEmpty()
class Duration 
invariant no_expr_requires_observation 
expr = null implies (observation->size() = 1 and observation->forAll(oclIsKindOf(DurationObservation)))
class DurationConstraint 
invariant first_event_multiplicity 
if (constrainedElement->size() = 2) then (firstEvent->size() = 2) else (firstEvent->size() = 0) endif
invariant has_one_or_two_constrainedElements 
constrainedElement->size() = 1 or constrainedElement->size()=2
class DurationObservation 
invariant first_event_multiplicity 
if (event->size() = 2) then (firstEvent->size() = 2) else (firstEvent->size() = 0) endif
class TimeConstraint 
invariant has_one_constrainedElement 
constrainedElement->size() = 1