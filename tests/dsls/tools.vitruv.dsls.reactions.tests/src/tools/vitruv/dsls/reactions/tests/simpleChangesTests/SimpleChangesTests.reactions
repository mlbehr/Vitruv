import tools.vitruv.dsls.reactions.tests.simpleChangesTests.SimpleChangesTestsExecutionMonitor
import static tools.vitruv.dsls.reactions.tests.simpleChangesTests.SimpleChangesTestsExecutionMonitor.ChangeType.*;

import "http://tools.vitruv.tests.metamodels.allElementTypes" as minimal

reactions: simpleChangesTests
in reaction to changes in minimal 
execute actions in minimal

/*
 * UpdateSingleValuedEAttribute
 */
reaction ReplacedSingleValuedPrimitiveTypeEAttribute {
	after attribute replaced at minimal::Root[singleValuedPrimitiveTypeEAttribute]
	call replaceSingleValuedPrimitiveTypeEAttribute(affectedEObject, newValue)
}

routine replaceSingleValuedPrimitiveTypeEAttribute(minimal::Root rootElement, Int value) {
	match {
		val targetElement = retrieve minimal::Root corresponding to rootElement
	}
	action {
		update targetElement {
			targetElement.singleValuedPrimitiveTypeEAttribute = value;
		}
		call {
			SimpleChangesTestsExecutionMonitor.instance.set(UpdateSingleValuedPrimitveTypeEAttribute);
		}
	} 
}

/*
 * UpdateSingleValuedEAttribute
 */
reaction ReplacedSingleValuedEAttribute {
	after attribute replaced at minimal::Root[singleValuedEAttribute]
	call replaceSingleValuedEAttribute(affectedEObject, newValue)
}

routine replaceSingleValuedEAttribute(minimal::Root rootElement, Int value) {
	match {
		// The check statements do only test that multiple check statements work
		check { rootElement != null }
		val targetElement = retrieve minimal::Root corresponding to rootElement
		check { value != null }
	}
	action {
		update targetElement {
			targetElement.singleValuedEAttribute = value;
		}
		call {
			SimpleChangesTestsExecutionMonitor.instance.set(UpdateSingleValuedEAttribute);
		}
	} 
}

/*
 * UpdateSingleValuedEAttribute
 */
reaction ReplacedNonRootId {
	after attribute replaced at  minimal::NonRoot[id]
	call replaceNonRootId(affectedEObject, newValue)
}

routine replaceNonRootId(minimal::NonRoot nonRoot, String value) {
	match {
		val targetElement = retrieve minimal::NonRoot corresponding to nonRoot
	}
	action {
		update targetElement {
			targetElement.id = value;
		}
	}
}

/*
 * CreateNonRootEObjectInList
 */
reaction CreatedNonRootEObjectInList {
	after element minimal::NonRoot created and inserted in minimal::Root[multiValuedContainmentEReference]
	call insertNonRoot(affectedEObject, newValue)
}

routine insertNonRoot(minimal::Root rootElement, minimal::NonRoot insertedNonRoot) {
	match {
		val targetElement = retrieve minimal::Root corresponding to rootElement
	}
	action {
		val newNonRoot = create minimal::NonRoot and initialize {
			newNonRoot.id = insertedNonRoot.id
		}
		update targetElement {
			targetElement.multiValuedContainmentEReference += newNonRoot;
		}
		add correspondence between newNonRoot and insertedNonRoot 
		call {
			SimpleChangesTestsExecutionMonitor.instance.set(CreateNonRootEObjectInList);
		}
	}
}

/*
 * DeleteNonRootEObjectInList
 */
reaction DeletedNonRootEObjectInList {
	after element minimal::NonRoot deleted and removed from minimal::Root[multiValuedContainmentEReference]
	call removeNonRoot(oldValue)
}

routine removeNonRoot(minimal::NonRoot removedNonRoot) {
	match {
		val targetElement = retrieve minimal::NonRoot corresponding to removedNonRoot
	}
	action {
		call {
			SimpleChangesTestsExecutionMonitor.instance.set(DeleteNonRootEObjectInList);
		}
		delete targetElement
	}
}

/*
 * ReplaceNonRootEObjectSingle
 */
reaction ReplacedNonRootEObjectSingleReaction {
	after element minimal::NonRoot replaced at minimal::Root[singleValuedContainmentEReference]
	call {
		if (oldValue != null) {
			deleteNonRootEObjectSingle(oldValue);
		}
		if (newValue != null) {
			createNonRootEObjectSingle(affectedEObject, newValue);
		}
	} 
}

routine deleteNonRootEObjectSingle(minimal::NonRoot containedObject) {
	match {
		val targetElement = retrieve minimal::NonRoot corresponding to containedObject
	}
	action {
		delete targetElement
		call {
			SimpleChangesTestsExecutionMonitor.instance.set(DeleteNonRootEObjectSingle);
		}
	}
}

routine createNonRootEObjectSingle(minimal::Root sourceRoot, minimal::NonRoot containedObject) {
	match {
		val targetElement = retrieve minimal::Root corresponding to sourceRoot
	}
	action {
		val newNonRoot = create minimal::NonRoot and initialize {
			newNonRoot.id = containedObject.id
		}
		update targetElement {
			targetElement.singleValuedContainmentEReference = newNonRoot;
		}
		add correspondence between newNonRoot and containedObject
		call {
			SimpleChangesTestsExecutionMonitor.instance.set(CreateNonRootEObjectSingle);
		}
	}
}

/*
 * UpdateSingleValuedNonContainmentEReference
 */
reaction ReplacedSingleValuedNonContainmentEReference {
	after element minimal::NonRoot replaced at minimal::Root[singleValuedNonContainmentEReference]
	call replaceSingleValuedNonContainmentReference(affectedEObject, newValue)
}

routine replaceSingleValuedNonContainmentReference(minimal::Root rootElement, minimal::NonRoot newReferencedElement
) {
	match {
		val targetContainer = retrieve minimal::Root corresponding to rootElement
		val targetElement = retrieve minimal::NonRoot corresponding to newReferencedElement
	}
	action {
		update targetContainer {
			targetContainer.singleValuedNonContainmentEReference = targetElement;
		}
		call {
			SimpleChangesTestsExecutionMonitor.instance.set(UpdateSingleValuedNonContainmentEReference);
		}
	}
}

/*
 * InsertEAttributeValue
 */
reaction InsertedEAttributeValue {
	after attribute insert in minimal::Root[multiValuedEAttribute] 
	call insertEAttribute(affectedEObject, newValue)
}

routine insertEAttribute(minimal::Root rootElement, Int attributeValue) {
	match {
		val targetElement = retrieve minimal::Root corresponding to rootElement
	}
	action {
		update targetElement {
			targetElement.multiValuedEAttribute.add(attributeValue);
		}
		call {
			SimpleChangesTestsExecutionMonitor.instance.set(InsertEAttributeValue);
		}
	}
}

/*
 * RemoveEAttributeValue
 */
reaction RemovedEAttributeValue {
	after attribute remove from minimal::Root[multiValuedEAttribute] 
	call removeEAttribute(affectedEObject, oldValue)
}

routine removeEAttribute(minimal::Root rootElement, Int removedAttributeValue) {
	match {
		val targetElement = retrieve minimal::Root corresponding to rootElement
	}
	action {
		update targetElement {
			val sourceValueList = rootElement.multiValuedEAttribute;
			targetElement.multiValuedEAttribute.removeIf[!sourceValueList.contains(it.intValue)];
		}
		call {
			SimpleChangesTestsExecutionMonitor.instance.set(RemoveEAttributeValue);
		}
	}
}

/*
 * InsertNonContainmentEReference
 */
reaction InsertedNonContainmentEReference {
	after element minimal::NonRoot inserted in minimal::Root[multiValuedNonContainmentEReference] 
	call insertNonContainmentReference(affectedEObject, newValue)
}

routine insertNonContainmentReference(minimal::Root rootElement, minimal::NonRoot insertedNonRoot) {
	match {
		val targetElement = retrieve minimal::Root corresponding to rootElement
	}
	action {
		update targetElement {
			val addedNonRoot = targetElement.nonRootObjectContainerHelper.nonRootObjectsContainment.findFirst[it.id == insertedNonRoot.id];
			targetElement.multiValuedNonContainmentEReference.add(addedNonRoot);
		}
		call {
			SimpleChangesTestsExecutionMonitor.instance.set(InsertNonContainmentEReference);
		}
	}
}


/*
 * RemoveNonContainmentEReference
 */
reaction RemovedNonContainmentEReference {
	after element minimal::NonRoot removed from minimal::Root[multiValuedNonContainmentEReference] 
	call removeNonContainmentReference(affectedEObject, oldValue)
}

routine removeNonContainmentReference(minimal::Root rootElement, minimal::NonRoot removedNonRoot) {
	match {
		val targetRoot = retrieve minimal::Root corresponding to rootElement
	}
	action {
		update targetRoot {
			targetRoot.multiValuedNonContainmentEReference.removeIf[it.id == removedNonRoot.id];
		}
		call {
			SimpleChangesTestsExecutionMonitor.instance.set(RemoveNonContainmentEReference);
		}
	}
}

routine createRoot(minimal::Root rootElement) {
	action {
		val newRoot = create minimal::Root and initialize {
			newRoot.id = rootElement.id;
		}
		add correspondence between newRoot and rootElement
		call {
			persistProjectRelative(rootElement, newRoot, "model/" + rootElement.id.replace("Source", "Target"));
		}
	}
}

routine deleteRoot(minimal::Root rootElement) {
	match {
		val oldModel = retrieve minimal::Root corresponding to rootElement
	}
	action {
		delete oldModel
	}
}

/*
 * Creates the model for comparing the further test model with.
 */
reaction CreateRootTest {
	after element minimal::Root created and inserted as root
	call createRoot(newValue)
}

reaction DeleteRootTest {
	after element minimal::Root deleted and removed as root
	call deleteRoot(oldValue)
}

/**
 * Initializes the nonRootObjectContainer for second model
 */
reaction HelperReactionForNonRootObjectContainerInitialization {
	after element minimal::NonRootObjectContainerHelper replaced at minimal::Root[nonRootObjectContainerHelper]
		with newValue != null
	call createNonRootObjectContainer(affectedEObject, newValue)
}

routine createNonRootObjectContainer(minimal::Root rootElement, minimal::NonRootObjectContainerHelper nonRootObjectContainer) {
	match {
		val targetElement = retrieve minimal::Root corresponding to rootElement
	}
	action {
		val newNonRootContainer = create minimal::NonRootObjectContainerHelper and initialize {
			newNonRootContainer.id = nonRootObjectContainer.id;
		}
		update targetElement {
			targetElement.nonRootObjectContainerHelper = newNonRootContainer;
		}
		add correspondence between newNonRootContainer and nonRootObjectContainer
	}
}

/**
 * Initializes the nonRootObjectContainer for second model
 */
reaction HelperReactionForNonRootObjectContainerContentsInitialization {
	after element minimal::NonRoot created and inserted in minimal::NonRootObjectContainerHelper[nonRootObjectsContainment]
	call createNonRootInContainer(affectedEObject, newValue)
}

routine createNonRootInContainer(minimal::NonRootObjectContainerHelper container, minimal::NonRoot insertedNonRoot) {
	match {
		val nonRootContainer = retrieve minimal::NonRootObjectContainerHelper corresponding to container
	}
	action {
		val newNonRoot = create minimal::NonRoot and initialize {
			newNonRoot.id = insertedNonRoot.id;
		}
		update nonRootContainer {
			nonRootContainer.nonRootObjectsContainment += newNonRoot;	
		}
		add correspondence between newNonRoot and insertedNonRoot
	}
}
